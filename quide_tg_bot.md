# Курсовая работа “Бот в Telegram”

> Привет! В данной шпаргалке мы описали дополнительные вводные, которые пригодятся вам при разработке бота.
>

# Методы библиотеки для взаимодействия с Telegram Bot API

## Создание бота

Бот создаётся либо вызовом конструктора у класс `TelegramBot`:

```java
TelegramBot bot = new TelegramBot("BOT_TOKEN");
```

Либо через использование паттерна строитель для тонкой настройки параметров http-соединения:

```java
TelegramBot bot = new TelegramBot.Builder("BOT_TOKEN").okHttpClient(client).build();
```

## Обработка входящих сообщений

Для обработки входящих сообщений необходимо зарегистрировать обработчик следующим образом:

```java
bot.setUpdatesListener(updates -> {
    // Обрабатываем входящие сообщения
    // возвращаем id последнего обработанного сообщения или отмечаем все как обработанные
    return UpdatesListener.CONFIRMED_UPDATES_ALL;
});
```

Подробнее на класс входящего обновления можно посмотреть здесь: `com.pengrad.telegrambot.model.Update`

## Отправка сообщений

Для начала необходимо создать само отправляемое сообщение, для этого указываем идентификатор чата, в который необходимо отправить сообщение и непосредственно текст сообщения:

```java
SendMessage message = new SendMessage(chatId, messageText)
```

Отправляется сообщение вызовом метода `execute`

```java
SendResponse response = bot.execute(message);
```

Класс `SendResponse` отвечает за результат отправки сообщения, например, вызовом метода `isOk()` можно проверить, действительно ли отправилось сообщение, а вызовом метода `errorCode()` можно узнать код ошибки, если таковая случилась.

## Прочие запросы

Метод `com.pengrad.telegrambot.TelegramBot#execute(com.pengrad.telegrambot.request.BaseRequest<T,R>)` может не только отправлять сообщения, но и выполнять другие виды запросов в Telegram Bot API. Такие классы с разными типами запросов наследуют `com.pengrad.telegrambot.request.BaseRequest<T,R>` и находятся в пакете `com.pengrad.telegrambot.response`.

Вы можете самостоятельно ознакомиться с этими классами и их соответствующим им методам Telegram Bot API в официальной документации: https://core.telegram.org/bots/api.

# Регулярные выражения

**Регулярные выражения** — используемый в компьютерных программах, работающих с текстом, формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов. Для поиска используется строка-образец (pattern), состоящая из символов и метасимволов и задающая правило поиска.

Язык регулярных выражений достаточно сложен и мы не будем его рассматривать, поговорим лиши о том, как использовать уже готовые паттерны в Java.

В Java за регулярные выражения отвечают два важных класса — Pattern и Matcher.

Pattern —  как раз задаёт паттерн для поиска (регулярное выражение). Для использования паттерн нужно скомпилировать вызовом метода `compile`. Пример паттерна для поиска строк без цифр:

```java
Pattern pattern = Pattern.compile("[a-zA-Z]")
```

Matcher — движок, который выполняет поиск по строке и использованием определенного паттерна и результат выполнения этого поиска. Нам интереснее второе — результат поиска. При использование паттерна может быть несколько совпадений в строке.

Чтобы проверить, удовлетворяет ли вообще строка паттерну, используют метод `matches`.

```java
Matcher matcher = pattern.matcher(string)
if (matcher.matches()) {
  // обрабатываем ситуацию, когда строка соответствует паттерну
}
```

Если же нам нужно не просто понять, соответствует ли строка паттерну, но и достать из неё необходимые соответствия, то для этого используется метод `Matcher.group(int group)`

```java
Matcher matcher = pattern.matcher(string);
if (matcher.matches()) {
    String date = matcher.group(1);
    String item = matcher.group(3);
}
```

# Выполнение методов по расписанию

Выполнение методов по расписанию — мощная возможность Spring Boot. Суть этой возможности в том, что можно в том или ином виде задать расписание и выполнять в соответствии с ним некоторый метод. Полезно, если нам, например, необходим делать запросы в некоторый внешний сервис с какой-то периодичностью или рассылать пользователям письма по утра/вечерам.

Для того, чтобы активировать функциональность шедулинга (выполнения методов по расписанию), необходимо по соседству с аннотацией `@SpringBootApplication` над классом, содержащим main метод вашего приложения, указать аннотацию `@EnableScheduling`.

Для того, чтобы выполнять метод по расписанию, достаточно, чтобы этот метод был публичным и имел аннотацию `@Scheduled`.

Рассмотрим способы, которыми можно через параметры аннотации `@Scheduled` задавать расписание выполнение метода.

`fixedDelay` — задаёт интервал между концом и началом выполнения метода в миллисекундах.

`fixedRate` — задаёт интервал между запусками метода в миллисекундах. В отличии от `fixedDelay` выполнения метода могут накладываться друг на друга, если время выполнения больше `fixedRate`.

`initialDelay` — интервал между запуском приложения и первым запуском метода.

`cron` — задаёт расписание в соответствии с синтаксисом cron expression. Позволяет задавать сложные расписания типа “в 12:12 по понедельникам в январе”

Пример запуска раз в секунду:

```java
@Scheduled(fixedDelay = 1_000L)
public void run() {

}
```

Пример запуска в 00 секунд каждой минуты

```java
@Scheduled(cron = "0 0/1 * * * *")
public void run() {

}
```

Бонус, пример запуска в в 12:12 по понедельникам в январе:

```java
@Scheduled(cron = "0 12 12 * 1 MON")
public void run() {

}
```